//! Kafka Event Generator (kgen)
//! A portable Rust-based Kafka producer for SIEM testing
//! Produces N JSON events to specified Kafka brokers and topic
//! Prints offsets to stdout for verification

use anyhow::{Context, Result};
use chrono::{DateTime, Utc};
use clap::Parser;
use rdkafka::config::ClientConfig;
use rdkafka::producer::{FutureProducer, FutureRecord, Producer};
use serde_json::{json, Value};
use std::time::Duration;
use tokio::time::timeout;

#[derive(Parser, Debug)]
#[command(name = "kgen")]
#[command(about = "Kafka Event Generator for SIEM testing")]
struct Args {
    /// Number of events to produce
    #[arg(short, long, default_value = "5")]
    count: usize,

    /// Kafka brokers (comma-separated)
    #[arg(short, long, env = "KAFKA_BROKERS", default_value = "localhost:9092")]
    brokers: String,

    /// Kafka topic to produce to
    #[arg(short, long, env = "KAFKA_TOPIC", default_value = "siem_events")]
    topic: String,

    /// Tenant ID for events
    #[arg(long, env = "TENANT_ID", default_value = "test_tenant")]
    tenant_id: String,

    /// Event prefix for unique identification
    #[arg(long, default_value = "kgen")]
    prefix: String,

    /// Timeout for each produce operation (seconds)
    #[arg(long, default_value = "10")]
    timeout: u64,

    /// Verbose output
    #[arg(short, long)]
    verbose: bool,
}

/// Generate a test event with the specified parameters
fn generate_event(event_id: &str, tenant_id: &str, sequence: usize) -> Value {
    let now: DateTime<Utc> = Utc::now();
    
    json!({
        "event_id": event_id,
        "tenant_id": tenant_id,
        "event_timestamp": now.to_rfc3339(),
        "event_type": "test_event",
        "event_category": "network",
        "event_action": "connection",
        "event_outcome": "success",
        "source_ip": format!("192.168.1.{}", 100 + (sequence % 155)),
        "destination_ip": "10.0.0.1",
        "source_port": 12345 + sequence,
        "destination_port": 80,
        "protocol": "TCP",
        "severity": "INFO",
        "message": format!("Test event {} generated by kgen", sequence),
        "user_id": format!("user_{}", sequence % 10),
        "user_name": format!("testuser{}", sequence % 10),
        "raw_event": json!({
            "generator": "kgen",
            "sequence": sequence,
            "tenant_id": tenant_id
        }),
        "metadata": json!({
            "generator": "kgen",
            "batch_id": format!("{}_batch", event_id.split('_').next().unwrap_or("unknown")),
            "generated_at": now.to_rfc3339()
        }),
        "__kgen__": true,
        "__test_batch__": format!("{}_batch", event_id.split('_').next().unwrap_or("unknown"))
    })
}

/// Create and configure Kafka producer
fn create_producer(brokers: &str) -> Result<FutureProducer> {
    let producer: FutureProducer = ClientConfig::new()
        .set("bootstrap.servers", brokers)
        .set("message.timeout.ms", "30000")
        .set("queue.buffering.max.messages", "100000")
        .set("queue.buffering.max.ms", "1000")
        .set("batch.num.messages", "1000")
        .set("compression.type", "snappy")
        .set("acks", "1")
        .set("retries", "3")
        .set("retry.backoff.ms", "100")
        .create()
        .context("Failed to create Kafka producer")?;
    
    Ok(producer)
}

#[tokio::main]
async fn main() -> Result<()> {
    let args = Args::parse();
    
    // Initialize logging
    if args.verbose {
        env_logger::Builder::from_env(env_logger::Env::default().default_filter_or("info")).init();
    }
    
    println!("=== Kafka Event Generator (kgen) ===");
    println!("Brokers: {}", args.brokers);
    println!("Topic: {}", args.topic);
    println!("Tenant ID: {}", args.tenant_id);
    println!("Event count: {}", args.count);
    println!("Event prefix: {}", args.prefix);
    println!();
    
    // Create producer
    let producer = create_producer(&args.brokers)
        .context("Failed to create Kafka producer")?;
    
    let timestamp = chrono::Utc::now().timestamp();
    let mut successful_sends = 0;
    let mut failed_sends = 0;
    
    println!("Producing {} events...", args.count);
    
    for i in 1..=args.count {
        let event_id = format!("{}_{}_{}_{}", args.prefix, timestamp, args.tenant_id, i);
        let event = generate_event(&event_id, &args.tenant_id, i);
        let event_json = serde_json::to_string(&event)
            .context("Failed to serialize event to JSON")?;
        
        if args.verbose {
            println!("Producing event {}: {}", i, event_id);
        }
        
        // Create the record
        let record = FutureRecord::to(&args.topic)
            .key(&event_id)
            .payload(&event_json);
        
        // Send with timeout
        let send_timeout = Duration::from_secs(args.timeout);
        match timeout(send_timeout, producer.send(record, Duration::from_secs(0))).await {
            Ok(Ok((partition, offset))) => {
                successful_sends += 1;
                println!("✅ Event {}: partition={}, offset={}, id={}", i, partition, offset, event_id);
            }
            Ok(Err((kafka_error, _))) => {
                failed_sends += 1;
                eprintln!("❌ Event {}: Kafka error: {}", i, kafka_error);
            }
            Err(_) => {
                failed_sends += 1;
                eprintln!("❌ Event {}: Timeout after {}s", i, args.timeout);
            }
        }
    }
    
    // Flush any remaining messages
    if args.verbose {
        println!("Flushing producer...");
    }
    
    match producer.flush(Duration::from_secs(30)) {
        Ok(()) => {
            if args.verbose {
                println!("✅ Producer flushed successfully");
            }
        }
        Err(e) => {
            eprintln!("⚠️  Producer flush error: {}", e);
        }
    }
    
    println!();
    println!("=== Summary ===");
    println!("Total events: {}", args.count);
    println!("Successful: {}", successful_sends);
    println!("Failed: {}", failed_sends);
    println!("Success rate: {:.1}%", (successful_sends as f64 / args.count as f64) * 100.0);
    
    if failed_sends > 0 {
        std::process::exit(1);
    }
    
    Ok(())
}